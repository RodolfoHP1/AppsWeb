"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDialectByNameOrAlias = void 0;
const { resolveClientNameWithAliases } = require('knex/lib/util/helpers');
const dbNameToDialectLoader = Object.freeze({
    'better-sqlite3': () => require('knex/lib/dialects/better-sqlite3'),
    cockroachdb: () => require('knex/lib/dialects/cockroachdb'),
    mssql: () => require('knex/lib/dialects/mssql'),
    mysql: () => require('knex/lib/dialects/mysql'),
    mysql2: () => require('knex/lib/dialects/mysql2'),
    oracle: () => require('knex/lib/dialects/oracle'),
    oracledb: () => require('knex/lib/dialects/oracledb'),
    pgnative: () => require('knex/lib/dialects/pgnative'),
    postgres: () => require('knex/lib/dialects/postgres'),
    redshift: () => require('knex/lib/dialects/redshift'),
    sqlite3: () => require('knex/lib/dialects/sqlite3'),
});
/**
 * Gets the Dialect object with the given client name or throw an
 * error if not found.
 *
 * NOTE: This is a replacement for prior practice of doing dynamic
 * string construction for imports of Dialect objects.
 */
function getDialectByNameOrAlias(clientName) {
    const resolvedClientName = resolveClientNameWithAliases(clientName);
    const dialectLoader = dbNameToDialectLoader[resolvedClientName];
    if (!dialectLoader) {
        throw new Error(`Invalid clientName given: ${clientName}`);
    }
    return dialectLoader();
}
exports.getDialectByNameOrAlias = getDialectByNameOrAlias;
//# sourceMappingURL=index.js.map